#include "adifall.ext"#include "epump.h"#include "edgesrv.h"#include "edge_io.h"#include "push_sess.h"#include "pull_sess.h"#include <string.h>int is_ikcp_head(uint8 *buf, int len){    // kcp head size = 24    if(len < 24) return 0;    if(buf[0] == 'A' && buf[1] == 'V' && buf[2] == 'K' && buf[3] == 'C' ){        return 1;    }    return 0;}int is_push_head(uint8 *buf, int len){    if(len < strlen("type=push,pushid=")) return 0;    if(strncmp(buf,"type=push,pushid=",strlen("type=push,pushid=")) == 0){        return 1;    }    return 0;}int is_pull_head(uint8 *buf, int len){    if(len < (24 + strlen("hb_sessid="))) return 0;    if(strncmp(buf+24,"hb_sessid=",strlen("hb_sessid=")) == 0){        return 1;    }    return 0;}int sock_get_pending (SOCKET fd){    int  pending = 0;    int  ret = 0;
    if (fd == INVALID_SOCKET) return 0;
#if defined(FIONREAD)#ifdef WINDOWS        ret = ioctlsocket(fd, FIONREAD, (u_long *)&pending);#endif#ifdef UNIX        ret = ioctl(fd, FIONREAD, &pending);#endif#endif    if (ret >= 0) return pending;    return ret;}int head_info_get(uint8 *buf, int len, uint8 *head, uint32 *ts, uint8 *type, uint32 *size){    uint32  first=0;    uint32  second=0;    uint8   H_TYPE=0;    uint32  H_PTS=0;    uint8   T_TYPE=0;    uint32  T_LEN = 0;    if(len < 8) return -1;    memcpy(&first,buf,4);    memcpy(&second,buf+4,4);        H_TYPE = first & 0xff;    H_PTS  = first >> 8;        T_TYPE = second & 0xff;    T_LEN  = second >> 8;    if(head)  *head = H_TYPE;    if(ts)    *ts   = H_PTS;    if(type)  *type = T_TYPE;    if(size)  *size = T_LEN;    return 0;}
int edge_body_recvfrom (void * vbody, void * pdev){    EdgeMgmt  *mgmt = (EdgeMgmt*)vbody;
	    uint8       rcvbuf[4096];    uint8     * pbuf = NULL;    int         toberead = 0;    struct sockaddr_in addr;    int         len = sizeof(addr);    int         ret = 0;    uint8       alloc = 0; 

		    if (!mgmt) return -1;
    while (1) {         toberead = sock_get_pending(iodev_fd(pdev));        if (toberead > sizeof(rcvbuf)) {             pbuf = kzalloc(toberead+1);            alloc = 1;        } else {             toberead = sizeof(rcvbuf);            pbuf = rcvbuf;             alloc = 0;        }
         memset(&addr, 0, sizeof(addr));        ret = recvfrom(iodev_fd(pdev), pbuf, toberead, 0,                        (struct sockaddr *)&addr, (socklen_t *)&len);        if (ret <= 0) {            if (alloc) { kfree(pbuf); pbuf = NULL; }            break;        }
 
#ifdef _DEBUG
//printf("Recvfrom %s:%d %d bytes\n", inet_ntoa(addr.sin_addr), ntohs(addr.sin_port), ret);
//printOctet(stdout, pbuf, 0, ret > 200 ? 200 : ret, 2);
#endif        edge_udpdata_parse(mgmt, pbuf, ret, &addr, pdev);        if (alloc) { kfree(pbuf); pbuf = NULL; }    }
     return 0;}

int edge_udpdata_parse(void * vbody, uint8 * pbuf, int buflen, struct sockaddr_in * addr, void * pdev){    EdgeMgmt    *mgmt = (EdgeMgmt *)vbody;
   uint64       sessid = 0;    uint64       runid  = 0;    uint64       pushid = 0;    uint8       *player = NULL;    uint8        state=0;    uint8        baseaddr[64];	struct in_addr peerip;	uint16         peerport;        if(buflen < sizeof(int)){        printf("edge_udpdata_parse [%s][%d] small message\n",pbuf,buflen);        return -1;    }    peerip = addr->sin_addr;    peerport = ntohs(addr->sin_port);    memset(baseaddr,0,sizeof(baseaddr));    sprintf(baseaddr,"%s:%d",inet_ntoa(peerip),peerport);    if(is_push_head(pbuf,buflen)){        // create push session        // get para        push_sess_para(pbuf,buflen,&sessid,&runid);        // open a push session        push_sess_restart(mgmt,sessid,runid);        // update addr        push_sess_addr(mgmt,sessid,baseaddr);        push_sess_peer(mgmt,sessid,addr);        // response hb        push_sess_sendkcp(mgmt,sessid,"hb",strlen("hb"));        return 0;    }    if(is_ikcp_head(pbuf,buflen)){        // if pull head        if(is_pull_head(pbuf,buflen)){            // get para            pull_sess_para(pbuf,buflen,&sessid,&runid,&pushid);            //create pull            pull_sess_restart(mgmt,sessid,runid);            // add addr -> sessid            pull_sess_addr(mgmt,sessid,addr);            // add pullid to push list            push_sess_add_list(mgmt,pushid,sessid);        }        addr_mgmt_sess_get(mgmt,baseaddr,&sessid,&state);        if(state){            // push                          push_sess_input(mgmt,sessid,pbuf,buflen);        }else{            // pull            pull_sess_input(mgmt,sessid,pbuf,buflen);        }            }    return 0;}

