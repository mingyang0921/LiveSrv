#include "adifall.ext"#include "epump.h"#include "edgesrv.h"#include "edge_io.h"#include "push_sess.h"#include "pull_sess.h"#include <string.h>int is_ikcp_head(const char *buf, int len){    // kcp head size = 24    if(len < 24) return 0;    if(buf[0] == 'A' && buf[1] == 'V' && buf[2] == 'K' && buf[3] == 'C' ){        return 1;    }    return 0;}int is_push_head(const char *buf, int len){    if(len < strlen("type=push,pushid=")) return 0;    if(strncmp(buf,"type=push,pushid=",strlen("type=push,pushid=")) == 0){        return 1;    }    return 0;}int sock_get_pending (SOCKET fd){    int  pending = 0;    int  ret = 0;
    if (fd == INVALID_SOCKET) return 0;
#if defined(FIONREAD)#ifdef WINDOWS        ret = ioctlsocket(fd, FIONREAD, (u_long *)&pending);#endif#ifdef UNIX        ret = ioctl(fd, FIONREAD, &pending);#endif#endif    if (ret >= 0) return pending;    return ret;}
int edge_body_recvfrom (void * vbody, void * pdev){    EdgeMgmt  *mgmt = (EdgeMgmt*)vbody;
	    uint8       rcvbuf[4096];    uint8     * pbuf = NULL;    int         toberead = 0;    struct sockaddr_in addr;    int         len = sizeof(addr);    int         ret = 0;    uint8       alloc = 0; 

		    if (!mgmt) return -1;
    while (1) {         toberead = sock_get_pending(iodev_fd(pdev));        if (toberead > sizeof(rcvbuf)) {             pbuf = kzalloc(toberead+1);            alloc = 1;        } else {             toberead = sizeof(rcvbuf);            pbuf = rcvbuf;             alloc = 0;        }
         memset(&addr, 0, sizeof(addr));        ret = recvfrom(iodev_fd(pdev), pbuf, toberead, 0,                        (struct sockaddr *)&addr, (socklen_t *)&len);        if (ret <= 0) {            if (alloc) { kfree(pbuf); pbuf = NULL; }            break;        }
 
#ifdef _DEBUG
//printf("Recvfrom %s:%d %d bytes\n", inet_ntoa(addr.sin_addr), ntohs(addr.sin_port), ret);
//printOctet(stdout, pbuf, 0, ret > 200 ? 200 : ret, 2);
#endif        edge_udpdata_parse(mgmt, pbuf, ret, &addr, pdev);        if (alloc) { kfree(pbuf); pbuf = NULL; }    }
     return 0;}

int edge_udpdata_parse(void * vbody, uint8 * pbuf, int buflen, struct sockaddr_in * addr, void * pdev){    EdgeMgmt    *mgmt = (EdgeMgmt *)vbody;
   uint64       sessid = 0;    uint64       runid  = 0;    uint64       pushid = 0;    uint8       *player = NULL;    uint8        state=0;    uint8        baseaddr[64];	struct in_addr peerip;	uint16         peerport;        if(buflen < sizeof(int)){        printf("edge_udpdata_parse [%s][%d] small message\n",pbuf,buflen);        return -1;    }        if(strncmp((const char*)pbuf,"type",strlen("type")) == 0){                push_sess_para(pbuf,buflen,&sessid,&runid);        // open a push session        push_sess_restart(mgmt,sessid,runid);        // update addr        push_sess_addr(mgmt,sessid,addr);                // response hb        push_sess_sendkcp(mgmt,sessid,"hb",strlen("hb"));                return 0;    }    if(pbuf[0] == 'A' && pbuf[1] == 'V' && pbuf[2] == 'K' && pbuf[3] == 'C' ){        player = pbuf + 24;        if(player && buflen > (24 + 16) && buflen < (24+16+50)){            if(strncmp(player,"hb_sessid",strlen("hb_sessid")) == 0){                pull_sess_para(pbuf,buflen,&sessid,&runid,&pushid);                pull_sess_restart(mgmt,sessid,runid);                pull_sess_addr(mgmt,sessid,addr);                push_sess_add_list(mgmt,pushid,sessid);            }        }        peerip = addr->sin_addr;        peerport = ntohs(addr->sin_port);        memset(baseaddr,0,sizeof(baseaddr));        sprintf(baseaddr,"%s:%d",inet_ntoa(peerip),peerport);        addr_mgmt_sess_get(mgmt,baseaddr,&sessid,&state);        if(state){            // push                          push_sess_input(mgmt,sessid,pbuf,buflen);        }else{            // pull            pull_sess_input(mgmt,sessid,pbuf,buflen);        }    }    return 0;}

